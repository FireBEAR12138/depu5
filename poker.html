<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>德州扑克</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #poker-table {
            width: 90vmin;
            height: 90vmin;
            position: relative;
            background: linear-gradient(145deg, #277234, #338f41);
            border-radius: 50%;
            border: 30px solid #2c1810;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5),
                        0 0 30px rgba(0,0,0,0.3);
        }

        .player {
            position: absolute;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }

        .player .name {
            font-size: 16px;
            margin-bottom: 3px;
            color: #ffd700;
            text-shadow: 0 0 5px rgba(255,215,0,0.5);
        }

        .player .chips {
            font-size: 14px;
            color: #fff;
            margin-bottom: 5px;
        }

        .player.thinking {
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            transform: scale(1.05);
        }

        .card {
            display: inline-block;
            width: 60px;
            height: 84px;
            background: #fff;
            border-radius: 5px;
            margin: 0 -10px;  /* 重叠效果 */
            text-align: center;
            font-size: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: 1px solid rgba(0,0,0,0.1);
            position: relative;
            transition: all 0.3s ease;
            transform-origin: center bottom;
            cursor: default;
        }

        /* 牌面布局 */
        .card .rank {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 16px;
            font-weight: bold;
        }

        .card .rank-bottom {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 16px;
            font-weight: bold;
            transform: rotate(180deg);
        }

        .card .suit {
            position: absolute;
            top: 22px;
            left: 5px;
            font-size: 16px;
        }

        .card .suit-bottom {
            position: absolute;
            bottom: 22px;
            right: 5px;
            font-size: 16px;
            transform: rotate(180deg);
        }

        .card .center-suit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
        }

        /* 牌背设计 */
        .card.back {
            background: linear-gradient(135deg, #600, #900);
            position: relative;
            overflow: hidden;
        }

        .card.back::before {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .card.back::after {
            content: "♠♣♥♦";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: rgba(255,255,255,0.2);
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            white-space: nowrap;
        }

        /* 悬浮效果 */
        .card:hover {
            transform: translateY(-5px) rotate(2deg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 10;
        }

        /* 红色花色样式 */
        .card .red {
            color: #d40000;
        }

        /* 黑色花色样式 */
        .card .black {
            color: #000;
        }

        /* 玩家手牌区域 */
        .cards {
            display: flex;
            justify-content: center;
            padding: 0 15px;
            height: 90px;
        }

        /* 公共牌区域 */
        #community-cards {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
            z-index: 100;
            min-width: 320px;
            min-height: 130px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #community-cards .card {
            margin: 0 2px;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        #community-cards .card:hover {
            transform: scale(1) translateY(-5px);
        }

        .role {
            position: absolute;
            width: 25px;
            height: 25px;
            top: -20px;
            right: -20px;
            background: linear-gradient(145deg, #ffd700, #ffed4a);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            border: 2px solid #fff;
            color: #000;
            font-size: 10px;
            z-index: 5;
        }

        #controls {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 15px;
            opacity: 0;
            transition: all 0.3s ease;
        }

        #controls.active {
            display: flex;
            opacity: 1;
        }

        button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.3s ease;
            background: linear-gradient(145deg, #333, #222);
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button[onclick*="fold"] { background: linear-gradient(145deg, #d32f2f, #b71c1c); }
        button[onclick*="call"] { background: linear-gradient(145deg, #388e3c, #2e7d32); }
        button[onclick*="raise"] { background: linear-gradient(145deg, #1976d2, #1565c0); }

        .player-status {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            animation: statusAppear 0.3s ease;
            z-index: 10;
            margin-top: 5px;
        }

        @keyframes statusAppear {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #result-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2c1810, #1a1a1a);
            color: white;
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            animation: modalPop 0.5s ease-out;
        }

        @keyframes modalPop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .result-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .result-header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
        }

        .result-title {
            color: #ffd700;
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255,215,0,0.3);
        }

        .winner-info {
            background: rgba(255,215,0,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .winner-name {
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .pot-amount {
            font-size: 18px;
            color: #fff;
            margin-bottom: 10px;
        }

        .hand-description {
            font-size: 16px;
            color: #aaa;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            margin-top: 10px;
        }

        .game-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .player-result {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .player-result:hover {
            transform: translateY(-5px);
        }

        .player-result.winner {
            background: rgba(255,215,0,0.1);
            border: 1px solid rgba(255,215,0,0.2);
        }

        .player-result.folded {
            opacity: 0.6;
        }

        .player-name {
            font-size: 18px;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }

        .player-status {
            font-size: 14px;
            color: #fff;
            margin-top: 5px;
        }

        .community-section {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 20px;
        }

        .section-title {
            font-size: 18px;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,215,0,0.3);
        }

        .modal-buttons button {
            padding: 12px 30px;
            font-size: 18px;
            background: linear-gradient(145deg, #ffd700, #ffed4a);
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c1810 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            transition: opacity 0.5s ease;
        }

        .game-title {
            color: #ffd700;
            font-size: 48px;
            margin-bottom: 50px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }

        .difficulty-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            max-width: 600px;
        }

        .difficulty-option {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .difficulty-option:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            border-color: #ffd700;
        }

        .difficulty-title {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .difficulty-description {
            color: #ffffff;
            font-size: 16px;
            opacity: 0.8;
            line-height: 1.4;
        }

        .difficulty-stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .stat {
            color: #ffffff;
            font-size: 14px;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-icon {
            font-size: 18px;
        }

        /* 添加装饰元素 */
        .card-decoration {
            position: absolute;
            font-size: 120px;
            opacity: 0.1;
            color: #ffffff;
            pointer-events: none;
        }

        .card-decoration:nth-child(1) { top: 10%; left: 10%; transform: rotate(-15deg); }
        .card-decoration:nth-child(2) { top: 20%; right: 10%; transform: rotate(15deg); }
        .card-decoration:nth-child(3) { bottom: 10%; left: 15%; transform: rotate(10deg); }
        .card-decoration:nth-child(4) { bottom: 20%; right: 15%; transform: rotate(-10deg); }

        #bgm-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 50%;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            z-index: 1000;
            font-size: 24px;
            color: #ffd700;
        }

        #bgm-control:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        #ai-speech {
            display: none;
            position: absolute;
            padding: 12px 16px;
            background: linear-gradient(145deg, #fff, #f8f8f8);
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 15px;
            font-weight: 500;
            min-width: 120px;
            max-width: 200px;
            text-align: center;
            z-index: 1001;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            animation: speechPop 0.3s ease-out;
            color: #000;
        }

        #ai-speech::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: #f8f8f8 transparent transparent;
        }

        @keyframes speechPop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes speechOut {
            0% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
        }

        .red {
            color: #d32f2f;
            text-shadow: 0 0 2px rgba(211,47,47,0.3);
        }

        /* 添加筹码图标 */
        .chips::before {
            content: "💰";
            margin-right: 5px;
        }

        /* 添加牌桌纹理 */
        #poker-table::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" fill="none"/><circle cx="10" cy="10" r="1" fill="rgba(255,255,255,0.1)"/></svg>');
            border-radius: 50%;
            opacity: 0.3;
        }

        #player1 { 
            bottom: 2%;
            left: 50%;
            transform: translateX(-50%);
        }

        #player2 { 
            right: 2%;
            top: 50%;
            transform: translateY(-50%);
        }

        #player3 { 
            top: 2%;
            left: 50%;
            transform: translateX(-50%);
        }

        #player4 { 
            left: 2%;
            top: 50%;
            transform: translateY(-50%);
        }

        .deck {
            position: absolute;
            right: 30%;
            top: 50%;
            transform: translateY(-50%);
        }

        .deck .card {
            position: absolute;
            margin-left: -48px;
        }

        .deck .card:nth-child(2) { transform: translateX(2px); }
        .deck .card:nth-child(3) { transform: translateX(4px); }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        #pot {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
        }

        .round-info {
            position: fixed;
            top: 20px;
            right: 80px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 24px;
            color: #ffd700;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            transform: none;
            left: auto;
        }

        .coffee-section {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            border: 1px solid rgba(255,215,0,0.2);
        }

        .coffee-section img {
            max-width: 300px;
            border-radius: 10px;
            margin: 10px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }

        .coffee-section img:hover {
            transform: scale(1.05);
        }

        .coffee-text {
            color: #ffd700;
            font-size: 18px;
            margin: 10px 0;
            text-shadow: 0 0 10px rgba(255,215,0,0.3);
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="card-decoration">♠</div>
        <div class="card-decoration">♥</div>
        <div class="card-decoration">♣</div>
        <div class="card-decoration">♦</div>
        
        <h1 class="game-title">德州扑克</h1>
        
        <div class="difficulty-container">
            <div class="difficulty-option" onclick="startGame('beginner')">
                <div class="difficulty-title">
                    <span class="difficulty-icon">🌟</span>
                    新手模式
                </div>
                <div class="difficulty-description">
                    适合初学者，AI较弱，更容易获胜。开局筹码更多，盲注更小。
                </div>
                <div class="difficulty-stats">
                    <div class="stat">
                        <span class="stat-icon">💰</span>
                        初始筹码: 2000
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🎲</span>
                        小盲注: 5
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🤖</span>
                        AI难度: 简单
                    </div>
                </div>
            </div>

            <div class="difficulty-option" onclick="startGame('intermediate')">
                <div class="difficulty-title">
                    <span class="difficulty-icon">🏆</span>
                    进阶模式
                </div>
                <div class="difficulty-description">
                    标准难度，AI具有正常策略标准筹码和盲注设置。
                </div>
                <div class="difficulty-stats">
                    <div class="stat">
                        <span class="stat-icon">💰</span>
                        初始筹码: 1000
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🎲</span>
                        小盲注: 10
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🤖</span>
                        AI难度: 中等
                    </div>
                </div>
            </div>

            <div class="difficulty-option" onclick="startGame('professional')">
                <div class="difficulty-title">
                    <span class="difficulty-icon">👑</span>
                    专业模式
                </div>
                <div class="difficulty-description">
                    挑战模式，AI更具侵略性。初始筹码更少，盲注更大。
                </div>
                <div class="difficulty-stats">
                    <div class="stat">
                        <span class="stat-icon">💰</span>
                        初始筹码: 500
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🎲</span>
                        小盲注: 20
                    </div>
                    <div class="stat">
                        <span class="stat-icon">🤖</span>
                        AI难度: 困难
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ai-speech"></div>

    <div id="poker-table">
        <div id="community-cards"></div>
        <div id="pot">池底: 0</div>
        <div id="player1" class="player">
            <div class="name">玩家</div>
            <div class="chips">1000</div>
            <div class="cards"></div>
        </div>
        <div id="player2" class="player">
            <div class="name">疯狂马克思</div>
            <div class="chips">1000</div>
            <div class="cards"></div>
        </div>
        <div id="player3" class="player">
            <div class="name">稳健老王</div>
            <div class="chips">1000</div>
            <div class="cards"></div>
        </div>
        <div id="player4" class="player">
            <div class="name">诡计多多</div>
            <div class="chips">1000</div>
            <div class="cards"></div>
        </div>
        <div id="controls">
            <button onclick="playerAction('fold')">弃牌</button>
            <button onclick="playerAction('call')">跟注</button>
            <button onclick="playerAction('raise')">加注</button>
        </div>
    </div>

    <div class="modal-overlay"></div>
    <div id="result-modal"></div>

    <div class="round-info">第 1 轮</div>

    <div id="bgm-control" onclick="toggleBGM()">🔊</div>

    <audio id="bgm" loop>
        <source src="https://cdn.freesound.org/previews/635/635476_14016667-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="card-shuffle">
        <source src="https://cdn.freesound.org/previews/523/523956_7724198-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="card-deal">
        <source src="https://cdn.freesound.org/previews/240/240777_4107740-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="chip-sound">
        <source src="https://cdn.freesound.org/previews/201/201806_3745836-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="fold-sound">
        <source src="https://cdn.freesound.org/previews/320/320181_5260872-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="win-sound">
        <source src="https://cdn.freesound.org/previews/270/270404_5123851-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="ai-aggressive">
        <source src="https://cdn.freesound.org/previews/416/416479_5121236-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="ai-conservative">
        <source src="https://cdn.freesound.org/previews/157/157296_2538033-lq.mp3" type="audio/mp3">
    </audio>

    <audio id="ai-tricky">
        <source src="https://cdn.freesound.org/previews/434/434479_8386899-lq.mp3" type="audio/mp3">
    </audio>

    <script>
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
            }

            toString() {
                const suits = {'♠': 'black', '♣': 'black', '♥': 'red', '♦': 'red'};
                const ranks = {
                    '14': 'A', '13': 'K', '12': 'Q', '11': 'J',
                    '10': '10', '9': '9', '8': '8', '7': '7',
                    '6': '6', '5': '5', '4': '4', '3': '3', '2': '2'
                };
                const rankText = ranks[this.rank];
                const suitClass = suits[this.suit];
                
                return `
                    <div class="${suitClass}">
                        <div class="rank">${rankText}</div>
                        <div class="suit">${this.suit}</div>
                        <div class="center-suit">${this.suit}</div>
                        <div class="rank-bottom">${rankText}</div>
                        <div class="suit-bottom">${this.suit}</div>
                    </div>
                `;
            }
        }

        class Player {
            constructor(name, type = 'human') {
                this.name = name;
                this.type = type;
                this.chips = 1000;
                this.cards = [];
                this.folded = false;
                this.currentBet = 0;
                this.lastAction = '';
            }

            reset() {
                this.cards = [];
                this.folded = false;
                this.currentBet = 0;
                this.lastAction = '';
            }
        }

        class SoundManager {
            constructor() {
                this.bgm = document.getElementById('bgm');
                this.cardShuffle = document.getElementById('card-shuffle');
                this.cardDeal = document.getElementById('card-deal');
                this.chipSound = document.getElementById('chip-sound');
                this.foldSound = document.getElementById('fold-sound');
                this.winSound = document.getElementById('win-sound');
                
                this.aiSounds = {
                    'aggressive': document.getElementById('ai-aggressive'),
                    'conservative': document.getElementById('ai-conservative'),
                    'tricky': document.getElementById('ai-tricky')
                };
                
                this.muted = false;
                this.volume = 0.5;
                
                // 初始化所有音频
                this.initializeAudio();
            }

            initializeAudio() {
                // 设置背景音乐
                this.bgm.volume = 0.2;
                
                // 设置音效音量
                [this.cardShuffle, this.cardDeal, this.chipSound, 
                 this.foldSound, this.winSound].forEach(sound => {
                    sound.volume = this.volume;
                });
                
                // 设置AI音效音量
                Object.values(this.aiSounds).forEach(sound => {
                    sound.volume = this.volume * 0.6;
                });
            }

            fadeIn(audio, duration = 1000) {
                let volume = 0;
                audio.volume = volume;
                
                const interval = 50;
                const steps = duration / interval;
                const increment = audio.volume / steps;
                
                const fadeInterval = setInterval(() => {
                    volume = Math.min(volume + increment, this.volume);
                    audio.volume = volume;
                    
                    if (volume >= this.volume) {
                        clearInterval(fadeInterval);
                    }
                }, interval);
            }

            fadeOut(audio, duration = 1000) {
                let volume = audio.volume;
                
                const interval = 50;
                const steps = duration / interval;
                const decrement = volume / steps;
                
                const fadeInterval = setInterval(() => {
                    volume = Math.max(volume - decrement, 0);
                    audio.volume = volume;
                    
                    if (volume <= 0) {
                        clearInterval(fadeInterval);
                        audio.pause();
                    }
                }, interval);
            }

            async playBGM() {
                if (this.muted) return;
                this.bgm.currentTime = 0;
                this.bgm.volume = 0;
                await this.bgm.play();
                this.fadeIn(this.bgm, 2000);
            }

            async playShuffle() {
                if (this.muted) return;
                const sound = this.cardShuffle;
                sound.currentTime = 0;
                sound.volume = this.volume * 0.7;
                await sound.play();
                setTimeout(() => this.fadeOut(sound, 500), 1000);
            }

            async playDeal() {
                if (this.muted) return;
                const sound = this.cardDeal;
                sound.currentTime = 0;
                sound.volume = this.volume * 0.5;
                await sound.play();
            }

            async playChips() {
                if (this.muted) return;
                const sound = this.chipSound;
                sound.currentTime = 0;
                sound.volume = this.volume * 0.8;
                await sound.play();
            }

            async playFold() {
                if (this.muted) return;
                const sound = this.foldSound;
                sound.currentTime = 0;
                sound.volume = this.volume * 0.4;
                await sound.play();
            }

            async playWin() {
                if (this.muted) return;
                // 淡出背景音乐
                this.fadeOut(this.bgm, 1000);
                
                const sound = this.winSound;
                sound.currentTime = 0;
                sound.volume = 0;
                await sound.play();
                this.fadeIn(sound, 1000);
                
                // 3秒后淡出胜利音效，恢复背景音乐
                setTimeout(() => {
                    this.fadeOut(sound, 1000);
                    this.fadeIn(this.bgm, 1000);
                }, 3000);
            }

            async playAiSound(type) {
                if (this.muted) return;
                const sound = this.aiSounds[type];
                if (sound) {
                    sound.currentTime = 0;
                    sound.volume = this.volume * 0.4;
                    await sound.play();
                }
            }

            toggleMute() {
                this.muted = !this.muted;
                
                const allSounds = [
                    this.bgm,
                    this.cardShuffle,
                    this.cardDeal,
                    this.chipSound,
                    this.foldSound,
                    this.winSound,
                    ...Object.values(this.aiSounds)
                ];
                
                allSounds.forEach(sound => {
                    sound.muted = this.muted;
                });
                
                document.getElementById('bgm-control').textContent = this.muted ? '🔈' : '🔊';
            }

            setVolume(value) {
                this.volume = Math.max(0, Math.min(1, value));
                this.initializeAudio();
            }
        }

        let soundManager = new SoundManager();

        function toggleBGM() {
            soundManager.toggleMute();
        }

        class PokerHand {
            static getHandRank(cards) {
                // 合并玩家手牌和公共牌
                const allCards = [...cards];
                
                // 排序
                allCards.sort((a, b) => b.rank - a.rank);
                
                // 检查各种牌型
                if (this.isRoyalFlush(allCards)) return { rank: 10, name: '皇家同花顺' };
                if (this.isStraightFlush(allCards)) return { rank: 9, name: '同花顺' };
                if (this.isFourOfAKind(allCards)) return { rank: 8, name: '四条' };
                if (this.isFullHouse(allCards)) return { rank: 7, name: '葫芦' };
                if (this.isFlush(allCards)) return { rank: 6, name: '同花' };
                if (this.isStraight(allCards)) return { rank: 5, name: '顺子' };
                if (this.isThreeOfAKind(allCards)) return { rank: 4, name: '三条' };
                if (this.isTwoPair(allCards)) return { rank: 3, name: '两对' };
                if (this.isOnePair(allCards)) return { rank: 2, name: '一' };
                return { rank: 1, name: '高牌' };
            }

            static isRoyalFlush(cards) {
                return this.isStraightFlush(cards) && cards[0].rank === 14;
            }

            static isStraightFlush(cards) {
                return this.isFlush(cards) && this.isStraight(cards);
            }

            static isFourOfAKind(cards) {
                const ranks = cards.map(c => c.rank);
                return new Set(ranks).size <= 4;
            }

            static isFullHouse(cards) {
                const rankCount = this.getRankCount(cards);
                return Object.values(rankCount).includes(3) && Object.values(rankCount).includes(2);
            }

            static isFlush(cards) {
                return new Set(cards.map(c => c.suit)).size === 1;
            }

            static isStraight(cards) {
                const ranks = [...new Set(cards.map(c => c.rank))].sort((a, b) => b - a);
                return ranks[0] - ranks[ranks.length - 1] === ranks.length - 1;
            }

            static isThreeOfAKind(cards) {
                const rankCount = this.getRankCount(cards);
                return Object.values(rankCount).includes(3);
            }

            static isTwoPair(cards) {
                const rankCount = this.getRankCount(cards);
                return Object.values(rankCount).filter(count => count === 2).length === 2;
            }

            static isOnePair(cards) {
                const rankCount = this.getRankCount(cards);
                return Object.values(rankCount).includes(2);
            }

            static getRankCount(cards) {
                const rankCount = {};
                cards.forEach(card => {
                    rankCount[card.rank] = (rankCount[card.rank] || 0) + 1;
                });
                return rankCount;
            }

            static getHandDescription(cards, handRank) {
                const ranks = {
                    '14': 'A', '13': 'K', '12': 'Q', '11': 'J',
                    '10': '10', '9': '9', '8': '8', '7': '7',
                    '6': '6', '5': '5', '4': '4', '3': '3', '2': '2'
                };

                let desc = `${handRank.name}：`;
                
                switch (handRank.rank) {
                    case 10:
                        desc += '同花色的AKQJ10';
                        break;
                    case 9:
                        const highCard = ranks[cards[0].rank];
                        desc += `${highCard}开头的同花顺`;
                        break;
                    case 8:
                        const fourRank = Object.entries(this.getRankCount(cards))
                            .find(([_, count]) => count === 4)[0];
                        desc += `四个${ranks[fourRank]}`;
                        break;
                    case 7:
                        const [threeRank] = Object.entries(this.getRankCount(cards))
                            .find(([_, count]) => count === 3)[0];
                        desc += `三个${ranks[threeRank]}带对子`;
                        break;
                    case 6:
                        desc += `${cards[0].suit}花`;
                        break;
                    case 5:
                        desc += `${ranks[cards[0].rank]}高的顺子`;
                        break;
                    case 4:
                        const tripleRank = Object.entries(this.getRankCount(cards))
                            .find(([_, count]) => count === 3)[0];
                        desc += `三个${ranks[tripleRank]}`;
                        break;
                    case 3:
                        const pairs = Object.entries(this.getRankCount(cards))
                            .filter(([_, count]) => count === 2)
                            .map(([rank, _]) => ranks[rank]);
                        desc += `${pairs[0]}对和${pairs[1]}对`;
                        break;
                    case 2:
                        const pairRank = Object.entries(this.getRankCount(cards))
                            .find(([_, count]) => count === 2)[0];
                        desc += `一对${ranks[pairRank]}`;
                        break;
                    case 1:
                        desc += `${ranks[cards[0].rank]}高牌`;
                        break;
                }
                
                return desc;
            }
        }

        class PokerGame {
            constructor(difficulty = 'intermediate') {
                this.difficulty = difficulty;
                this.players = [
                    new Player('玩家', 'human'),
                    new Player('疯狂马克思', 'aggressive'),
                    new Player('稳健老王', 'conservative'),
                    new Player('诡计多多', 'tricky')
                ];
                
                // 根据难度设置配置
                switch(difficulty) {
                    case 'beginner':
                        this.initialChips = 2000;
                        this.smallBlind = 5;
                        break;
                    case 'professional':
                        this.initialChips = 500;
                        this.smallBlind = 20;
                        break;
                    default:
                        this.initialChips = 1000;
                        this.smallBlind = 10;
                }

                this.players.forEach(p => p.chips = this.initialChips);
                
                this.deck = [];
                this.communityCards = [];
                this.pot = 0;
                this.currentPlayer = 0;
                this.dealer = 0;
                this.currentBet = 0;
                this.round = 1;
                this.gameOver = false;
                this.initDeck();
                
                // 开始背景音乐
                soundManager.playBGM();
            }

            initDeck() {
                const suits = ['♠', '♣', '♥', '♦'];
                const ranks = Array.from({length: 13}, (_, i) => i + 2);
                this.deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.deck.push(new Card(suit, rank));
                    }
                }
            }

            shuffle() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            async startGame() {
                if (this.gameOver) {
                    return;
                }

                document.querySelector('.round-info').textContent = `第 ${this.round} 轮`;
                
                this.initDeck();
                this.shuffle();
                this.pot = 0;
                this.communityCards = [];
                this.currentBet = 0;
                
                // Reset players
                this.players.forEach(p => p.reset());

                // 播放洗牌音效
                soundManager.playShuffle();
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Deal cards with sound
                for (let i = 0; i < 2; i++) {
                    for (let player of this.players) {
                        player.cards.push(this.deck.pop());
                        soundManager.playDeal();
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }

                // 设置位置（逆时针顺序）
                this.dealer = (this.dealer + 1) % 4;  // 庄家
                const sb = (this.dealer + 1) % 4;     // 小盲
                const bb = (this.dealer + 2) % 4;     // 大盲

                // 先收小盲注
                this.players[sb].chips -= this.smallBlind;
                this.players[sb].currentBet = this.smallBlind;
                soundManager.playChips();
                await new Promise(resolve => setTimeout(resolve, 500));

                // 再收大盲注
                this.players[bb].chips -= this.smallBlind * 2;
                this.players[bb].currentBet = this.smallBlind * 2;
                soundManager.playChips();
                await new Promise(resolve => setTimeout(resolve, 500));

                this.pot = this.smallBlind * 3;
                this.currentBet = this.smallBlind * 2;

                this.updateUI();
                await this.playRound();
            }

            async playRound() {
                // Pre-flop
                await this.bettingRound();
                if (this.getActivePlayers().length > 1) {
                    // Flop
                    for (let i = 0; i < 3; i++) {
                        this.communityCards.push(this.deck.pop());
                    }
                    this.updateUI();
                    await this.bettingRound();
                }

                if (this.getActivePlayers().length > 1) {
                    // Turn
                    this.communityCards.push(this.deck.pop());
                    this.updateUI();
                    await this.bettingRound();
                }

                if (this.getActivePlayers().length > 1) {
                    // River
                    this.communityCards.push(this.deck.pop());
                    this.updateUI();
                    await this.bettingRound();
                }

                this.showdown();
            }

            getActivePlayers() {
                return this.players.filter(p => !p.folded);
            }

            async bettingRound() {
                if (this.communityCards.length === 0) {
                    // 第一轮（翻牌前）：从大盲下家开始
                    this.currentPlayer = (this.dealer + 3) % 4;
                } else {
                    // 后续轮次：从小盲开始
                    this.currentPlayer = (this.dealer + 1) % 4;
                }

                let roundComplete = false;
                let lastRaisePlayer = null;
                let playersActed = 0;  // 记录已行动的玩家数
                
                while (!roundComplete) {
                    if (this.getActivePlayers().length === 1) break;

                    // 更新UI和按钮状态
                    this.updateUI();
                    this.updateControls();

                    // 如果玩家已经弃牌，跳到下一个玩家
                    if (this.players[this.currentPlayer].folded) {
                        this.currentPlayer = (this.currentPlayer + 1) % 4;
                        continue;
                    }

                    // 第一轮特殊处理：确保所有玩家都有机会行动
                    if (this.communityCards.length === 0) {
                        if (playersActed >= this.getActivePlayers().length && 
                            this.checkBetsEqual()) {
                            break;
                        }
                    } else {
                        // 其他轮次：如果回到最后加注者且所有玩家下注相等，结束轮次
                        if (lastRaisePlayer === this.currentPlayer && 
                            this.checkBetsEqual()) {
                            break;
                        }
                    }

                    if (this.players[this.currentPlayer].type === 'human') {
                        await new Promise(resolve => window.resolveAction = resolve);
                    } else {
                        await this.aiAction();
                    }

                    playersActed++;

                    if (this.players[this.currentPlayer].lastAction === 'raise') {
                        lastRaisePlayer = this.currentPlayer;
                    }

                    this.currentPlayer = (this.currentPlayer + 1) % 4;
                    roundComplete = this.checkRoundComplete();
                }

                this.hideControls();
            }

            checkBetsEqual() {
                const activePlayers = this.getActivePlayers();
                const bets = activePlayers.map(p => p.currentBet);
                return new Set(bets).size === 1;
            }

            async aiAction() {
                this.hideControls();
                
                const player = this.players[this.currentPlayer];
                document.getElementById(`player${this.currentPlayer + 1}`).classList.add('thinking');
                
                await new Promise(resolve => setTimeout(resolve, 2000));

                let action;
                const callAmount = this.currentBet - player.currentBet;
                
                // 调整AI策略的激进程度
                let aggressiveChance, conservativeChance, trickyChance;
                let raiseMultiplier;  // 加注倍数

                switch(this.difficulty) {
                    case 'beginner':
                        aggressiveChance = 0.6;  // 提高激进概率
                        conservativeChance = 0.4;
                        trickyChance = 0.5;
                        raiseMultiplier = 3;  // 加注为小盲注的3倍
                        break;
                    case 'professional':
                        aggressiveChance = 0.9;  // 非常激进
                        conservativeChance = 0.3;
                        trickyChance = 0.8;
                        raiseMultiplier = 5;  // 加注为小盲注的5倍
                        break;
                    default:
                        aggressiveChance = 0.8;  // 较为激进
                        conservativeChance = 0.35;
                        trickyChance = 0.7;
                        raiseMultiplier = 4;  // 加注为小盲注的4倍
                }
                
                // 根据AI类型决定行动
                switch (player.type) {
                    case 'aggressive':
                        action = Math.random() < aggressiveChance ? 'raise' : 'call';
                        // 降低弃牌概率
                        if (callAmount > player.chips * 0.7) {  // 从0.5改为0.7
                            action = Math.random() < 0.3 ? 'fold' : 'call';  // 30%概率弃牌
                        }
                        break;
                    case 'conservative':
                        action = Math.random() < conservativeChance ? 'call' : 'raise';
                        if (callAmount > player.chips * 0.5) {
                            action = Math.random() < 0.4 ? 'fold' : 'call';  // 40%概率弃牌
                        }
                        break;
                    case 'tricky':
                        action = Math.random() < trickyChance ? 'raise' : 'call';
                        if (callAmount > player.chips * 0.6) {
                            action = Math.random() < 0.35 ? 'fold' : 'call';  // 35%概率弃牌
                        }
                        break;
                }

                // 显示AI对话
                const speeches = {
                    'aggressive': {
                        'fold': [
                            '这局子老子不耍了，忒黑咯！',
                            '莫得意思，撂担子算咯！',
                            '这牌烂得很，不耍咯！'
                        ],
                        'call': [
                            '安逸，老子跟到！',
                            '莫慌莫慌，跟就跟嘛！',
                            '有啥子好怕的，跟！'
                        ],
                        'raise': [
                            '加注！看你们顶不顶得住！',
                            '加大加大，莫要怂嘛！',
                            '老子就要加注，你们咋个整？'
                        ],
                        'check': [
                            '过嘛过嘛，莫急！',
                            '稳住稳住，慢慢来！',
                            '看你们啷个耍！'
                        ],
                        'allin': [
                            '老子梭哈了！有种跟到底！',
                            '全部押上，就干到底！',
                            '看老子这次豁出去了！'
                        ]
                    },
                    'conservative': {
                        'fold': [
                            '这局子不安逸，算咯！',
                            '形不妙，莫耍咯！',
                            '这牌面不得行，歇会儿！'
                        ],
                        'call': [
                            '跟就跟嘛，莫着急！',
                            '安逸，慢慢耍！',
                            '妥点，跟住！'
                        ],
                        'raise': [
                            '加注，你们要想清楚哦！',
                            '加点筹，莫要乱投',
                            '加注，你们要三思哦！'
                        ],
                        'check': [
                            '稳住稳住，莫慌！',
                            '过牌，看你们咋个耍！',
                            '慢慢来，莫急！'
                        ],
                        'allin': [
                            '这把值得梭哈！',
                            '破釜沉舟，全部押上！',
                            '豁出去了，全下！'
                        ]
                    },
                    'tricky': {
                        'fold': [
                            '这局子不耍咯，下次再整！',
                            '今天运气不得行，算咯！',
                            '莫得意思，撤咯！'
                        ],
                        'call': [
                            '有意思，跟到底！',
                            '看你们啷个耍，跟了！',
                            '莫要以为我不晓得你们在整啥子！'
                        ],
                        'raise': [
                            '加注！你们猜我是不是在虚张声势？',
                            '要得要得，加大点！',
                            '加注！看你们敢不敢跟！'
                        ],
                        'check': [
                            '先过着，莫要着急！',
                            '看你们啷个耍嘛！',
                            '慢慢来，有的是时间！'
                        ],
                        'allin': [
                            '要得，老子梭哈了！',
                            '全部押上，你们敢不敢？',
                            '看我这次玩这么大！'
                        ]
                    }
                };

                const actionType = callAmount === 0 && action === 'call' ? 'check' : action;
                const aiType = player.type;
                const speechList = speeches[aiType][actionType];
                const speech = speechList[Math.floor(Math.random() * speechList.length)];

                this.showAiSpeech(player.name, speech);

                document.getElementById(`player${this.currentPlayer + 1}`).classList.remove('thinking');

                player.lastAction = action;
                
                switch (action) {
                    case 'fold':
                        player.folded = true;
                        soundManager.playFold();
                        break;
                    case 'call':
                        if (callAmount === 0) {
                            player.lastAction = 'check';
                        }
                        this.pot += callAmount;
                        player.chips -= callAmount;
                        player.currentBet = this.currentBet;
                        soundManager.playChips();
                        break;
                    case 'raise':
                        // 增加加注金额
                        const raiseAmount = Math.min(
                            player.chips,
                            this.currentBet + this.smallBlind * raiseMultiplier  // 使用新的加注倍数
                        );
                        this.pot += raiseAmount;
                        player.chips -= raiseAmount;
                        this.currentBet = player.currentBet = raiseAmount;
                        soundManager.playChips();
                        break;
                    case 'allin':
                        const allinAmount = player.chips;
                        this.pot += allinAmount;
                        player.chips = 0;
                        player.currentBet += allinAmount;
                        if (player.currentBet > this.currentBet) {
                            this.currentBet = player.currentBet;
                        }
                        soundManager.playChips();
                        break;
                }

                this.updateUI();
            }

            checkRoundComplete() {
                const activePlayers = this.getActivePlayers();
                if (activePlayers.length === 1) return true;

                // 检查所有未弃牌的玩家下注是否相等
                const bets = activePlayers.map(p => p.currentBet);
                return new Set(bets).size === 1 && bets[0] === this.currentBet;
            }

            showdown() {
                this.hideControls();
                
                let result = `
                    <div class="result-content">
                        <div class="result-header">
                            <h2 class="result-title">本局结算</h2>
                        </div>
                `;

                const activePlayers = this.getActivePlayers();
                let winner, winnerHand;

                if (activePlayers.length === 1) {
                    winner = activePlayers[0];
                    winner.chips += this.pot;
                    result += `
                        <div class="winner-info">
                            <div class="winner-name">${winner.name}</div>
                            <div class="pot-amount">获得筹码: ${this.pot}</div>
                            <div class="hand-description">其他玩家已弃牌</div>
                        </div>
                    `;
                } else {
                    const playerHands = activePlayers.map(player => {
                        const availableCards = [...player.cards, ...this.communityCards];
                        const handRank = PokerHand.getHandRank(availableCards);
                        return {
                            player,
                            handRank,
                            description: PokerHand.getHandDescription(availableCards, handRank)
                        };
                    });

                    playerHands.sort((a, b) => b.handRank.rank - a.handRank.rank);
                    winner = playerHands[0].player;
                    winnerHand = playerHands[0];
                    winner.chips += this.pot;

                    result += `
                        <div class="winner-info">
                            <div class="winner-name">${winner.name}</div>
                            <div class="pot-amount">获得筹码: ${this.pot}</div>
                            <div class="hand-description">${winnerHand.description}</div>
                        </div>
                    `;
                }

                // 检查游戏是否结束
                const gameOverStatus = this.checkGameOver();
                if (gameOverStatus.isOver) {
                    result += `
                        <div class="game-over-info" style="margin: 20px 0; padding: 20px; background: rgba(255,0,0,0.1); border-radius: 10px;">
                            <h3 style="color: #ff4444; margin-bottom: 10px;">游戏结束</h3>
                            <div>最终获胜者: ${gameOverStatus.winner.name}</div>
                            <div>获胜筹码: ${gameOverStatus.winner.chips}</div>
                            <div style="margin-top: 10px;">
                                破产玩家: ${gameOverStatus.bankruptPlayers.map(p => p.name).join(', ')}
                            </div>
                        </div>
                    `;
                }

                result += '<div class="game-summary">';
                this.players.forEach(player => {
                    const isWinner = player === winner;
                    const handRank = player.folded ? null : PokerHand.getHandRank([...player.cards, ...this.communityCards]);
                    
                    result += `
                        <div class="player-result ${isWinner ? 'winner' : ''} ${player.folded ? 'folded' : ''}">
                            <div class="player-name">${player.name}</div>
                            <div class="player-cards">
                                ${player.cards.map(card => 
                                    `<div class="card">${card.toString()}</div>`
                                ).join('')}
                            </div>
                            <div class="player-status">
                                ${player.folded ? 
                                    '<span class="fold-tag">已弃牌</span>' : 
                                    `<span class="hand-type">${handRank.name}</span>`
                                }
                                <div class="chips-amount">当前筹码: ${player.chips}</div>
                            </div>
                        </div>
                    `;
                });
                result += '</div>';

                if (this.communityCards.length > 0) {
                    result += `
                        <div class="community-section">
                            <div class="section-title">公共牌</div>
                            <div class="community-cards">
                                ${this.communityCards.map(card => 
                                    `<div class="card">${card.toString()}</div>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                }

                result += `
                    <div class="modal-buttons">
                        ${gameOverStatus.isOver ? 
                            `<button onclick="restartGame()">重新开始</button>` :
                            `<button onclick="continueGame()">继续游戏</button>`
                        }
                    </div>
                </div>`;

                const modal = document.getElementById('result-modal');
                const overlay = document.querySelector('.modal-overlay');
                
                modal.innerHTML = result;
                modal.style.display = 'block';
                overlay.style.display = 'block';
                
                soundManager.playWin();

                // 如果游戏结束，阻止继续游戏
                if (gameOverStatus.isOver) {
                    this.gameOver = true;
                }
            }

            updateUI() {
                // 更新池底显示
                document.getElementById('pot').textContent = `池底: ${this.pot}`;

                // 更新公共牌
                const communityCardsDiv = document.getElementById('community-cards');
                communityCardsDiv.innerHTML = this.communityCards.map(card => 
                    `<div class="card">${card.toString()}</div>`
                ).join('');

                // 更新玩家
                this.players.forEach((player, index) => {
                    const playerDiv = document.getElementById(`player${index + 1}`);
                    playerDiv.querySelector('.chips').textContent = player.chips;
                    
                    const cardsDiv = playerDiv.querySelector('.cards');
                    if (index === 0 || player.folded) {
                        // 显示玩家自己的牌或弃牌的牌
                        cardsDiv.innerHTML = player.cards.map(card => 
                            `<div class="card">${card.toString()}</div>`
                        ).join('');
                    } else {
                        // 显示其他玩家的牌背
                        cardsDiv.innerHTML = player.cards.map(() => 
                            `<div class="card back"></div>`
                        ).join('');
                    }

                    if (player.folded) {
                        playerDiv.classList.add('folded');
                    } else {
                        playerDiv.classList.remove('folded');
                    }

                    // 移除旧的状态显示
                    const oldStatus = playerDiv.querySelector('.player-status');
                    if (oldStatus) {
                        oldStatus.remove();
                    }

                    // 添加新的状态显示
                    if (player.folded || player.lastAction) {
                        const statusDiv = document.createElement('div');
                        statusDiv.className = 'player-status';
                        
                        if (player.folded) {
                            statusDiv.classList.add('status-fold');
                            statusDiv.textContent = '已弃牌';
                        } else if (player.lastAction) {
                            const actionText = {
                                'fold': '弃牌',
                                'call': '跟注',
                                'raise': '加注',
                                'check': '过牌'
                            };
                            statusDiv.classList.add(`status-${player.lastAction}`);
                            statusDiv.textContent = actionText[player.lastAction];
                            if (player.currentBet > 0) {
                                statusDiv.textContent += ` ${player.currentBet}`;
                            }
                        }
                        
                        playerDiv.appendChild(statusDiv);
                    }
                });

                // Update positions
                const positions = ['庄家', '小盲', '大盲'];
                document.querySelectorAll('.role').forEach(el => el.remove());
                
                for (let i = 0; i < 3; i++) {
                    const position = (this.dealer + i) % 4;
                    const playerDiv = document.getElementById(`player${position + 1}`);
                    const roleDiv = document.createElement('div');
                    roleDiv.className = 'role';
                    roleDiv.textContent = positions[i];
                    playerDiv.appendChild(roleDiv);
                }
            }

            showAiSpeech(name, text) {
                const playerDiv = document.getElementById(`player${this.currentPlayer + 1}`);
                const speechDiv = document.createElement('div');
                speechDiv.id = 'ai-speech';
                speechDiv.textContent = text;
                
                // 移除可能存在的旧对话框
                const oldSpeech = playerDiv.querySelector('#ai-speech');
                if (oldSpeech) {
                    oldSpeech.remove();
                }

                // 添加到玩家div中
                playerDiv.appendChild(speechDiv);
                
                // 显示对话框
                speechDiv.style.display = 'block';

                // 2秒后移除
                setTimeout(() => {
                    speechDiv.style.animation = 'speechOut 0.3s ease-out';
                    setTimeout(() => {
                        speechDiv.remove();
                    }, 300);
                }, 2000);
            }

            checkGameOver() {
                const bankruptPlayers = this.players.filter(p => p.chips <= 0);
                if (bankruptPlayers.length > 0) {
                    this.gameOver = true;
                    // 找出获胜者（筹码最多的玩家）
                    const winner = this.players.reduce((prev, current) => 
                        (prev.chips > current.chips) ? prev : current
                    );
                    return {
                        isOver: true,
                        winner: winner,
                        bankruptPlayers: bankruptPlayers
                    };
                }
                return { isOver: false };
            }

            showCoffeeModal() {
                return new Promise(resolve => {
                    const modal = document.getElementById('result-modal');
                    const overlay = document.querySelector('.modal-overlay');
                    
                    const content = `
                        <div class="result-content">
                            <div class="result-header">
                                <h2 class="result-title">请我喝杯咖啡吧 ☕</h2>
                            </div>
                            <div class="coffee-section">
                                <div class="coffee-text">喜欢这个游戏吗？支持一下开发者吧~</div>
                                <img src="https://s21.ax1x.com/2024/11/15/pA2C6nx.jpg" alt="Buy me a coffee">
                                <div class="coffee-text" style="font-size: 14px; color: #aaa; margin-top: 10px;">
                                    扫码赞赏，支持游戏持续更新 💝
                                </div>
                            </div>
                            <div class="modal-buttons">
                                <button onclick="closeCoffeeModal()">继续游戏</button>
                            </div>
                        </div>
                    `;
                    
                    modal.innerHTML = content;
                    modal.style.display = 'block';
                    overlay.style.display = 'block';
                    
                    window.coffeeModalResolve = resolve;
                });
            }

            async continueGame() {
                if (this.gameOver) {
                    return;
                }

                this.round++;

                // 检查是否需要显示咖啡弹窗
                if (this.round === 2 || this.round % 10 === 0) {
                    const modal = document.getElementById('result-modal');
                    const overlay = document.querySelector('.modal-overlay');
                    modal.style.display = 'none';
                    overlay.style.display = 'none';

                    // 等待咖啡弹窗关闭
                    await this.showCoffeeModal();
                }

                // 重置游戏状态
                this.pot = 0;
                this.communityCards = [];
                this.currentBet = 0;
                this.players.forEach(p => p.reset());
                
                const modal = document.getElementById('result-modal');
                const overlay = document.querySelector('.modal-overlay');
                modal.style.display = 'none';
                overlay.style.display = 'none';

                this.startGame();
            }

            // 新增：更新控制按钮显示状态
            updateControls() {
                const controls = document.getElementById('controls');
                if (this.currentPlayer === 0 && !this.players[0].folded) {
                    controls.classList.add('active');
                    
                    const player = this.players[0];
                    const callAmount = this.currentBet - player.currentBet;
                    const raiseAmount = Math.min(
                        player.chips,
                        this.currentBet + this.smallBlind * 2
                    );
                    
                    // 如果玩家筹码不够跟注，只显示 allin 和弃牌选项
                    if (callAmount >= player.chips) {
                        controls.innerHTML = `
                            <button onclick="playerAction('fold')">弃牌</button>
                            <button onclick="playerAction('allin')" style="background: linear-gradient(145deg, #ff9800, #f57c00);">全下 ${player.chips}</button>
                        `;
                    } else {
                        controls.innerHTML = `
                            <button onclick="playerAction('fold')">弃牌</button>
                            <button onclick="playerAction('call')">${callAmount === 0 ? '过牌' : '跟注 ' + callAmount}</button>
                            <button onclick="playerAction('raise')">加注 ${raiseAmount}</button>
                            <button onclick="playerAction('allin')" style="background: linear-gradient(145deg, #ff9800, #f57c00);">全下 ${player.chips}</button>
                        `;
                    }
                } else {
                    controls.classList.remove('active');
                }
            }

            // 新增：隐藏控制按钮
            hideControls() {
                const controls = document.getElementById('controls');
                controls.classList.remove('active');
            }
        }

        let game;

        function startGame(difficulty) {
            const startScreen = document.getElementById('start-screen');
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
                startScreen.style.opacity = '1';
                game = new PokerGame(difficulty);
                game.startGame();
            }, 500);
        }

        function playerAction(action) {
            if (game.currentPlayer !== 0) return;

            const player = game.players[0];
            const callAmount = game.currentBet - player.currentBet;

            player.lastAction = action;
            if (action === 'call' && callAmount === 0) {
                player.lastAction = 'check';
            }

            switch (action) {
                case 'allin':
                    const allinAmount = player.chips;
                    game.pot += allinAmount;
                    player.chips = 0;
                    player.currentBet += allinAmount;
                    if (player.currentBet > game.currentBet) {
                        game.currentBet = player.currentBet;
                    }
                    soundManager.playChips();
                    break;
                case 'fold':
                    player.folded = true;
                    soundManager.playFold();
                    break;
                case 'call':
                    if (callAmount <= player.chips) {
                        game.pot += callAmount;
                        player.chips -= callAmount;
                        player.currentBet = game.currentBet;
                        soundManager.playChips();
                    }
                    break;
                case 'raise':
                    const raiseAmount = Math.min(
                        player.chips,
                        game.currentBet + game.smallBlind * 2
                    );
                    game.pot += raiseAmount;
                    player.chips -= raiseAmount;
                    game.currentBet = player.currentBet = raiseAmount;
                    soundManager.playChips();
                    break;
            }

            game.updateUI();  // 立即更新显示
            window.resolveAction();
        }

        function continueGame() {
            game.continueGame();
        }

        function restartGame() {
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('result-modal').style.display = 'none';
            document.querySelector('.modal-overlay').style.display = 'none';
            game = null; // 清除当前游戏实例
        }

        // 添加关闭咖啡弹窗的函数
        function closeCoffeeModal() {
            const modal = document.getElementById('result-modal');
            const overlay = document.querySelector('.modal-overlay');
            modal.style.display = 'none';
            overlay.style.display = 'none';
            
            if (window.coffeeModalResolve) {
                window.coffeeModalResolve();
                window.coffeeModalResolve = null;
            }
        }
    </script>
</body>
</html> 